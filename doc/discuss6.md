# 第六次讨论

目前的验证器能够支持if语句了。控制语句的加入意味着需要考虑如何产生基本路径，而不是从前往后拼起来就好。

一开始我考虑的是一些tricky的方法边遍历AST边生成基本路径，后来发现这样不太好做（相当于某种在dfs序上的dfs），细节很难考虑，可能行不通（尤其考虑到return语句）。所以最终使用的方法是记录基本块之间的控制流转移关系，在控制流图上dfs。

if语句的两个分支对应于两个assume动作。一条基本路径中，if语句的条件被假设为成立，另一条被假设为不成立，二者的控制流转移不一样。

return语句的问题在于它不仅会改变返回值，还会结束控制流。在之前的实验中，return语句会生成`jr ra`，所以之后的语句自然地不会执行，即便生成了死代码也只是会增大生成代码的体积。但是在这个实验中，return语句需要被特殊处理。否则如果之后有assert、之后有return或者控制流抵达了函数的结尾，那么不该加入的assertion会被加入进来。

我的做法是给基本块加一个`terminate`标志，return语句会导致它被置为真，之后的动作和后续基本块的转移关系不会被加给`terminate`为`true`的基本块。同时，在dfs时用它来判断抵达了基本路径结尾的标志。在后面做循环的时候，需要把函数的执行路径用循环不变式“切开"，那时也可以使用`terminate`标志。

对于没有return语句就抵达结尾的情况，并不把它规定为错误，只是规定返回值未定义——如果postcondition需要对返回值的保证，就无法通过验证。